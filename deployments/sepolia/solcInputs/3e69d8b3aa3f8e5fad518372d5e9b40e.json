{
  "language": "Solidity",
  "sources": {
    "contracts/WorkAgreement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IERC20 {\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract WorkAgreement {\n    // --------------------------------------------------------------------------------\n    // Enums\n    // --------------------------------------------------------------------------------\n\n    enum JobStatus {\n        Open,\n        InProgress,\n        Delivered,\n        Completed,\n        Disputed,\n        Resolved,\n        Cancelled\n    }\n\n    // --------------------------------------------------------------------------------\n    // Structs\n    // --------------------------------------------------------------------------------\n\n    struct Job {\n        address client;\n        address contractor;\n        uint256 depositAmount;\n        // tokenAddressがaddress(0)の場合、ネイティブトークン（Ether）での入金とする\n        address tokenAddress;\n        JobStatus status;\n        string title;\n        string description;\n        uint256 deadline;\n        string jobURI;\n        uint256 deliveredTimestamp;\n        // deliverWork時に納品物のURLを記録するフィールド\n        string submissionURI;\n    }\n\n    // --------------------------------------------------------------------------------\n    // State Variables\n    // --------------------------------------------------------------------------------\n\n    uint256 public jobCounter;\n    mapping(uint256 => Job) public jobs;\n\n    address public disputeResolver;\n    uint256 public constant AUTO_APPROVE_PERIOD = 7 days;\n\n    // 管理者（owner）: 特定の操作の制御に利用\n    address public owner;\n    // 再入可能性対策用のロック変数\n    bool private locked;\n\n    // --------------------------------------------------------------------------------\n    // Events\n    // --------------------------------------------------------------------------------\n\n    event JobCreated(\n        uint256 indexed jobId,\n        address indexed client,\n        uint256 depositAmount,\n        address token,\n        string title,\n        string description,\n        uint256 deadline,\n        string jobURI\n    );\n    event JobApplied(uint256 indexed jobId, address indexed contractor);\n    event JobStarted(uint256 indexed jobId, address indexed contractor);\n    // deliverWork時に納品物のURLを出力するように変更\n    event JobDelivered(uint256 indexed jobId, string submissionURI);\n    event JobCompleted(uint256 indexed jobId);\n    event JobDisputed(uint256 indexed jobId);\n    event JobResolved(uint256 indexed jobId, bool disputeUpheld);\n    event JobCancelled(uint256 indexed jobId);\n    event JobDeadlineCancelled(uint256 indexed jobId);\n\n    // --------------------------------------------------------------------------------\n    // Modifiers\n    // --------------------------------------------------------------------------------\n\n    modifier validJobId(uint256 _jobId) {\n        require(_jobId != 0 && _jobId <= jobCounter, \"Invalid job ID\");\n        _;\n    }\n\n    modifier validStatus(uint256 _jobId, JobStatus _requiredStatus) {\n        require(jobs[_jobId].status == _requiredStatus, \"Invalid job status\");\n        _;\n    }\n\n    modifier onlyClient(uint256 _jobId) {\n        require(msg.sender == jobs[_jobId].client, \"Only the client can call this function\");\n        _;\n    }\n\n    modifier onlyContractor(uint256 _jobId) {\n        require(msg.sender == jobs[_jobId].contractor, \"Only the contractor can call this function\");\n        _;\n    }\n\n    modifier onlyDisputeResolver() {\n        require(msg.sender == disputeResolver, \"Only the assigned dispute resolver can call\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    /// 再入攻撃対策の簡易的な修飾子（非再入可能）\n    modifier nonReentrant() {\n        require(!locked, \"ReentrancyGuard: reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    // --------------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------------\n\n    constructor(address _disputeResolver) {\n        disputeResolver = _disputeResolver;\n        owner = msg.sender;\n    }\n\n    // --------------------------------------------------------------------------------\n    // Fallback / Receive\n    // --------------------------------------------------------------------------------\n\n    // ネイティブトークン受信用（直接Etherが送られた場合の対策）\n    receive() external payable { }\n\n    // --------------------------------------------------------------------------------\n    // Internal Utility Functions\n    // --------------------------------------------------------------------------------\n\n    /**\n     * @dev tokenAddress が address(0) の場合はネイティブトークンの送金を行い、\n     *      それ以外の場合はERC20トークンのtransferを実行する。\n     */\n    function _transferFunds(\n        address _tokenAddress,\n        address _recipient,\n        uint256 _amount\n    )\n        internal\n        returns (bool)\n    {\n        if (_tokenAddress == address(0)) {\n            // ネイティブ送金の場合、_recipient を payable にキャスト\n            (bool success,) = payable(_recipient).call{ value: _amount }(\"\");\n            return success;\n        } else {\n            return IERC20(_tokenAddress).transfer(_recipient, _amount);\n        }\n    }\n\n    // --------------------------------------------------------------------------------\n    // Main Functions\n    // --------------------------------------------------------------------------------\n\n    /**\n     * @notice クライアントが仕事を作成する（報酬のデポジット含む）\n     * @dev _tokenAddress が address(0) の場合はネイティブトークン（Ether）での入金とする。\n     */\n    function createJob(\n        address _tokenAddress,\n        uint256 _depositAmount,\n        string calldata _title,\n        string calldata _description,\n        uint256 _deadline,\n        string calldata _jobURI\n    )\n        external\n        payable\n        returns (uint256 jobId)\n    {\n        require(_depositAmount > 0, \"Deposit must be greater than 0\");\n        require(_deadline > block.timestamp, \"Deadline must be in the future\");\n\n        if (_tokenAddress == address(0)) {\n            // ネイティブトークンの場合、送信されたEther (msg.value) が _depositAmount と一致する必要がある\n            require(msg.value == _depositAmount, \"Sent value must equal deposit amount\");\n        } else {\n            // ERC20の場合、msg.value は0である必要があり、approve済みのトークンから入金される\n            require(msg.value == 0, \"Do not send native token when using ERC20\");\n            bool success =\n                IERC20(_tokenAddress).transferFrom(msg.sender, address(this), _depositAmount);\n            require(success, \"Token transfer failed\");\n        }\n\n        jobCounter++;\n        jobId = jobCounter;\n\n        jobs[jobId] = Job({\n            client: msg.sender,\n            contractor: address(0),\n            depositAmount: _depositAmount,\n            tokenAddress: _tokenAddress,\n            status: JobStatus.Open,\n            title: _title,\n            description: _description,\n            deadline: _deadline,\n            jobURI: _jobURI,\n            deliveredTimestamp: 0,\n            submissionURI: \"\"\n        });\n\n        emit JobCreated(\n            jobId,\n            msg.sender,\n            _depositAmount,\n            _tokenAddress,\n            _title,\n            _description,\n            _deadline,\n            _jobURI\n        );\n    }\n\n    /**\n     * @notice コントラクターが応募する\n     */\n    function applyForJob(uint256 _jobId)\n        external\n        validJobId(_jobId)\n        validStatus(_jobId, JobStatus.Open)\n    {\n        require(jobs[_jobId].contractor == address(0), \"Contractor already assigned\");\n        jobs[_jobId].contractor = msg.sender;\n        emit JobApplied(_jobId, msg.sender);\n    }\n\n    /**\n     * @notice クライアントが契約開始する（応募したコントラクターを選定）\n     */\n    function startContract(\n        uint256 _jobId,\n        address _selectedContractor\n    )\n        external\n        validJobId(_jobId)\n        onlyClient(_jobId)\n        validStatus(_jobId, JobStatus.Open)\n    {\n        require(\n            jobs[_jobId].contractor == _selectedContractor, \"Not matched with selected contractor\"\n        );\n        jobs[_jobId].status = JobStatus.InProgress;\n        emit JobStarted(_jobId, _selectedContractor);\n    }\n\n    /**\n     * @notice コントラクターが納品する（納品物のURLを指定）\n     */\n    function deliverWork(\n        uint256 _jobId,\n        string calldata _submissionURI\n    )\n        external\n        validJobId(_jobId)\n        onlyContractor(_jobId)\n        validStatus(_jobId, JobStatus.InProgress)\n    {\n        Job storage job = jobs[_jobId];\n        require(block.timestamp <= job.deadline, \"Deadline passed, cannot deliver\");\n\n        job.status = JobStatus.Delivered;\n        job.deliveredTimestamp = block.timestamp;\n        job.submissionURI = _submissionURI;\n\n        emit JobDelivered(_jobId, _submissionURI);\n    }\n\n    /**\n     * @notice クライアントが納品を承認して job を完了する\n     */\n    function approveAndComplete(uint256 _jobId)\n        external\n        validJobId(_jobId)\n        onlyClient(_jobId)\n        validStatus(_jobId, JobStatus.Delivered)\n    {\n        jobs[_jobId].status = JobStatus.Completed;\n        emit JobCompleted(_jobId);\n    }\n\n    /**\n     * @notice コントラクターが報酬を引き出す\n     */\n    function withdrawPayment(uint256 _jobId)\n        external\n        validJobId(_jobId)\n        onlyContractor(_jobId)\n        validStatus(_jobId, JobStatus.Completed)\n        nonReentrant\n    {\n        Job storage job = jobs[_jobId];\n        uint256 amount = job.depositAmount;\n        job.depositAmount = 0;\n        job.status = JobStatus.Resolved;\n\n        bool success = _transferFunds(job.tokenAddress, msg.sender, amount);\n        require(success, \"Payment transfer failed\");\n    }\n\n    /**\n     * @notice 自動承認（納品後一定期間経過時にDeliveredからCompletedへ）\n     */\n    function autoApproveIfTimeoutPassed(uint256 _jobId)\n        external\n        validJobId(_jobId)\n        validStatus(_jobId, JobStatus.Delivered)\n    {\n        require(\n            block.timestamp >= jobs[_jobId].deliveredTimestamp + AUTO_APPROVE_PERIOD,\n            \"Auto-approval period not passed\"\n        );\n        jobs[_jobId].status = JobStatus.Completed;\n        emit JobCompleted(_jobId);\n    }\n\n    /**\n     * @notice 納品前に期限を過ぎた job を自動キャンセルする（InProgress状態かつdeadline超過）\n     */\n    function autoCancelIfDeadlinePassed(uint256 _jobId) external validJobId(_jobId) nonReentrant {\n        Job storage job = jobs[_jobId];\n        require(job.status == JobStatus.InProgress, \"Invalid job status\");\n        require(block.timestamp > job.deadline, \"Deadline not passed yet\");\n\n        job.status = JobStatus.Cancelled;\n        uint256 amount = job.depositAmount;\n        job.depositAmount = 0;\n\n        bool success = _transferFunds(job.tokenAddress, job.client, amount);\n        require(success, \"Refund to client failed\");\n\n        emit JobDeadlineCancelled(_jobId);\n    }\n\n    /**\n     * @notice 紛争を申し立てる（ClientまたはContractorが呼び出し可能）\n     */\n    function raiseDispute(uint256 _jobId) external validJobId(_jobId) {\n        Job storage job = jobs[_jobId];\n        require(msg.sender == job.client || msg.sender == job.contractor, \"Not authorized\");\n        require(\n            job.status == JobStatus.InProgress || job.status == JobStatus.Delivered,\n            \"Cannot dispute in this status\"\n        );\n        job.status = JobStatus.Disputed;\n        emit JobDisputed(_jobId);\n    }\n\n    /**\n     * @notice 紛争解決者が裁定する\n     * @param _disputeUpheld trueの場合、Client勝訴（返金）、falseの場合、Contractor勝訴（支払い）\n     */\n    function resolveDispute(\n        uint256 _jobId,\n        bool _disputeUpheld\n    )\n        external\n        validJobId(_jobId)\n        onlyDisputeResolver\n        validStatus(_jobId, JobStatus.Disputed)\n        nonReentrant\n    {\n        Job storage job = jobs[_jobId];\n        job.status = JobStatus.Resolved;\n        uint256 amount = job.depositAmount;\n        job.depositAmount = 0;\n\n        bool success;\n        if (_disputeUpheld) {\n            // Client勝訴 → 返金\n            success = _transferFunds(job.tokenAddress, job.client, amount);\n            require(success, \"Refund to client failed\");\n        } else {\n            // Contractor勝訴 → 支払い\n            success = _transferFunds(job.tokenAddress, job.contractor, amount);\n            require(success, \"Payment to contractor failed\");\n        }\n        emit JobResolved(_jobId, _disputeUpheld);\n    }\n\n    /**\n     * @notice Clientがjobをキャンセルする（Open状態のみ）\n     */\n    function cancelJob(uint256 _jobId)\n        external\n        validJobId(_jobId)\n        onlyClient(_jobId)\n        validStatus(_jobId, JobStatus.Open)\n    {\n        Job storage job = jobs[_jobId];\n        job.status = JobStatus.Cancelled;\n        uint256 amount = job.depositAmount;\n        job.depositAmount = 0;\n\n        bool success = _transferFunds(job.tokenAddress, msg.sender, amount);\n        require(success, \"Refund failed\");\n        emit JobCancelled(_jobId);\n    }\n\n    /**\n     * @notice 指定されたjobの情報を返す\n     */\n    function getJob(uint256 _jobId)\n        external\n        view\n        returns (\n            address client_,\n            address contractor_,\n            uint256 depositAmount_,\n            address tokenAddress_,\n            JobStatus status_,\n            string memory title_,\n            string memory description_,\n            uint256 deadline_,\n            string memory jobURI_,\n            uint256 deliveredAt_,\n            string memory submissionURI_\n        )\n    {\n        Job storage job = jobs[_jobId];\n        return (\n            job.client,\n            job.contractor,\n            job.depositAmount,\n            job.tokenAddress,\n            job.status,\n            job.title,\n            job.description,\n            job.deadline,\n            job.jobURI,\n            job.deliveredTimestamp,\n            job.submissionURI\n        );\n    }\n\n    /**\n     * @notice 管理者(owner)のみが呼び出し可能: 紛争解決者の変更\n     */\n    function setDisputeResolver(address _resolver) external onlyOwner {\n        disputeResolver = _resolver;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}